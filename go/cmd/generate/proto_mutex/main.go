package main

import (
	"flag"
	"log"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func getGoScalarType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Int32Kind:
		return "int32"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "interface{}"
	}
}

func main() {
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(p *protogen.Plugin) error {
		p.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range p.Files {
			if !f.Generate {
				continue
			}

			g := p.NewGeneratedFile(f.GeneratedFilenamePrefix+"_mutex.pb.go", f.GoImportPath)
			g.P("// Code generated by proto_mutex. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)
			g.P()
			g.P("import (")
			g.P("    \"sync\"")
			g.P("    \"google.golang.org/protobuf/proto\"")
			g.P(")")
			g.P()

			for _, msg := range f.Messages {
				msgName := msg.GoIdent.GoName
				concurrentMsgName := "Concurrent" + msgName

				g.P("type ", concurrentMsgName, " struct {")
				g.P("    data *", msgName)
				g.P("    mu   sync.RWMutex")
				g.P("}")
				g.P()
				g.P("func New", concurrentMsgName, "(data *", msgName, ") *", concurrentMsgName, " {")
				g.P("    if data == nil { data = &", msgName, "{} }")
				g.P("    return &", concurrentMsgName, "{data: data}")
				g.P("}")
				g.P()

				for _, field := range msg.Fields {
					fieldName := field.GoName
					getterName := "Get" + fieldName
					setterName := "Set" + fieldName
					concurrentMsgName := "Concurrent" + msg.GoIdent.GoName

					var goType string

					if field.Desc.IsList() {
						goType = "[]"
						if field.Message != nil {
							goType += "*" + g.QualifiedGoIdent(field.Message.GoIdent)
						} else {
							goType += getGoScalarType(field.Desc.Kind())
						}
					} else if field.Desc.IsMap() {
						mapEntry := field.Message
						if mapEntry == nil || len(mapEntry.Fields) != 2 {
							log.Fatalf("ERROR: During proto mutex Invalid map entry descriptor for %s ", fieldName)
						} else {
							keyFieldDesc := mapEntry.Fields[0]
							valueFieldDesc := mapEntry.Fields[1]

							keyGoType := getGoScalarType(keyFieldDesc.Desc.Kind())

							var valueGoType string
							if valueFieldDesc.Message != nil {
								valueGoType = "*" + g.QualifiedGoIdent(valueFieldDesc.Message.GoIdent)
							} else {
								valueGoType = getGoScalarType(valueFieldDesc.Desc.Kind())
							}
							goType = "map[" + keyGoType + "]" + valueGoType
						}

					} else if field.Message != nil {
						goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
					} else {
						scalarType := getGoScalarType(field.Desc.Kind())

						makePointer := field.Desc.HasOptionalKeyword() || // Proto3 'optional' keyword
							(field.Desc.ContainingOneof() != nil && !field.Desc.ContainingOneof().IsSynthetic()) // Part of a 'real' oneof

						if makePointer {
							goType = "*" + scalarType
						} else {
							goType = scalarType
						}
					}

					// --- Getter Generation ---
					g.P("func (m *", concurrentMsgName, ") ", getterName, "() ", goType, " {")
					g.P("    m.mu.RLock()")
					g.P("    defer m.mu.RUnlock()")

					if field.Message != nil {
						if field.Desc.IsList() {
							g.P("    if m.data.", fieldName, " == nil { return nil }")
							g.P("    clonedSlice := make(", goType, ", len(m.data.", fieldName, "))")
							g.P("    for i, item := range m.data.", fieldName, " {")
							g.P("        if item != nil {")
							g.P("            clonedSlice[i] = proto.Clone(item).(*", g.QualifiedGoIdent(field.Message.GoIdent), ")")
							g.P("        }")
							g.P("    }")
							g.P("    return clonedSlice")
						} else if field.Desc.IsMap() {
							mapEntry := field.Message
							valueFieldDesc := mapEntry.Fields[1]

							g.P("    if m.data.", fieldName, " == nil { return nil }")
							g.P("    clonedMap := make(", goType, ", len(m.data.", fieldName, "))")
							g.P("    for k, v := range m.data.", fieldName, " {")
							if valueFieldDesc.Message != nil {
								valueMsgGoIdent := g.QualifiedGoIdent(valueFieldDesc.Message.GoIdent)
								g.P("        if v != nil {")
								g.P("            clonedMap[k] = proto.Clone(v).(*", valueMsgGoIdent, ")")
								g.P("        } else {")
								g.P("            clonedMap[k] = nil // Preserve nil if original value was nil")
								g.P("        }")
							} else {
								g.P("        clonedMap[k] = v")
							}
							g.P("    }")
							g.P("    return clonedMap")
						} else {
							g.P("    if m.data.", fieldName, " == nil { return nil }")
							g.P("    return proto.Clone(m.data.", fieldName, ").(*", g.QualifiedGoIdent(field.Message.GoIdent), ")")
						}
					} else {
						g.P("    return m.data.", fieldName)
					}
					g.P("}")
					g.P()

					// --- Setter Generation ---
					if field.Oneof == nil {
						g.P("func (m *", concurrentMsgName, ") ", setterName, "(val ", goType, ") {")
						g.P("    m.mu.Lock()")
						g.P("    defer m.mu.Unlock()")
						g.P("    m.data.", fieldName, " = val")
						g.P("}")
						g.P()
					}
				}

				g.P("func (m *", concurrentMsgName, ") GetProtoClone() *", msgName, " {")
				g.P("    m.mu.RLock()")
				g.P("    defer m.mu.RUnlock()")
				g.P("    return proto.Clone(m.data).(*", msgName, ")")
				g.P("}")
				g.P()
			}
		}
		return nil
	})
}
