package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func getGoScalarType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Int32Kind:
		return "int32"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "interface{}"
	}
}

const cacheTemplate = `// Code generated by proto_mutex; DO NOT EDIT.
package {{.GoPackageName}} 

import (
	"sync"
	"sync/atomic"
	"time"
)

type CacheItem[V any] struct {
	Value      V            // must be thread-safe
	LastAccess atomic.Value // time.Time
}

func newCacheItem[V any](value V) *CacheItem[V] {
	item := &CacheItem[V]{
		Value: value,
	}
	item.LastAccess.Store(time.Now())
	return item
}

type InternalCache[K comparable, V any] struct {
	internal sync.Map
}

func NewInternalCache[K comparable, V any]() *InternalCache[K, V] {
	return &InternalCache[K, V]{}
}

func (c *InternalCache[K, V]) Load(key K) (V, bool) {
	item, ok := c.LoadItem(key)
	if !ok {
		var zero V
		return zero, false
	}
	return item.Value, true
}

func (c *InternalCache[K, V]) Store(key K, value V) {
	c.internal.Store(key, newCacheItem(value))
}

func (c *InternalCache[K, V]) CleanupOlderThan(olderThan time.Time) {
	c.internal.Range(func(k, v any) bool {
		item := v.(*CacheItem[V])
		lastAccess := item.LastAccess.Load().(time.Time)

		if olderThan.After(lastAccess) {
			c.internal.Delete(k)
		}

		return true
	})
}

func (c *InternalCache[K, V]) LoadOrStore(key K, value V) (V, bool) {
	newItem := newCacheItem(value)
	actual, loaded := c.internal.LoadOrStore(key, newItem)

	actualItem := actual.(*CacheItem[V])
	if loaded {
		actualItem.LastAccess.Store(time.Now())
	}

	return actualItem.Value, loaded
}

func (c *InternalCache[K, V]) Delete(key K) {
	c.internal.Delete(key)
}

func (c *InternalCache[K, V]) Range(f func(key K, value V) bool) {
	c.internal.Range(func(key, value interface{}) bool {
		k := key.(K)
		item := value.(*CacheItem[V])
		item.LastAccess.Store(time.Now())
		return f(k, item.Value)
	})
}

func (c *InternalCache[K, V]) LoadItem(key K) (*CacheItem[V], bool) {
	value, ok := c.internal.Load(key)
	if !ok {
		return nil, false
	}
	item := value.(*CacheItem[V])
	item.LastAccess.Store(time.Now())
	return item, true
}

func (c *InternalCache[K, V]) CompareAndSwap(key K, oldItem *CacheItem[V], newValue V) bool {
	newItem := newCacheItem(newValue)
	return c.internal.CompareAndSwap(key, oldItem, newItem)
}
`

func main() {
	var flags flag.FlagSet

	opts := protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(p *protogen.Plugin) error {
		p.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		var genCache bool
		for _, f := range p.Files {
			if !f.Generate {
				continue
			}

			if !genCache {

				c := p.NewGeneratedFile(filepath.Join(filepath.Dir(f.GeneratedFilenamePrefix), "cache_impl.pb.go"), f.GoImportPath)
				tmpl, err := template.New("cache").Parse(cacheTemplate)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
					os.Exit(1)
				}

				data := struct {
					GoPackageName protogen.GoPackageName
				}{
					GoPackageName: f.GoPackageName,
				}

				err = tmpl.Execute(c, data)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
					os.Exit(1)
				}

				genCache = true
			}

			g := p.NewGeneratedFile(f.GeneratedFilenamePrefix+"_mutex.pb.go", f.GoImportPath)
			g.P("// Code generated by proto_mutex. DO NOT EDIT.")
			g.P("package ", f.GoPackageName)
			g.P()
			g.P("import (")
			g.P("  \"sync\"")
			g.P("  \"google.golang.org/protobuf/proto\"")
			g.P(")")
			g.P()

			for _, msg := range f.Messages {
				msgName := msg.GoIdent.GoName
				concurrentMsgName := "Concurrent" + msgName

				g.P("type ", concurrentMsgName, " struct {")
				g.P("  data *", msgName)
				g.P("  mu   sync.RWMutex")
				g.P("}")
				g.P()
				g.P("func New", concurrentMsgName, "(data *", msgName, ") *", concurrentMsgName, " {")
				g.P("  if data == nil { data = &", msgName, "{} }")
				g.P("  return &", concurrentMsgName, "{data: data}")
				g.P("}")
				g.P()

				for _, field := range msg.Fields {
					fieldName := field.GoName
					getterName := "Get" + fieldName
					setterName := "Set" + fieldName
					concurrentMsgName := "Concurrent" + msg.GoIdent.GoName

					var goType string

					if field.Desc.IsList() {
						goType = "[]"
						if field.Message != nil {
							goType += "*" + g.QualifiedGoIdent(field.Message.GoIdent)
						} else {
							goType += getGoScalarType(field.Desc.Kind())
						}
					} else if field.Desc.IsMap() {
						mapEntry := field.Message
						if mapEntry == nil || len(mapEntry.Fields) != 2 {
							log.Fatalf("ERROR: During proto mutex Invalid map entry descriptor for %s ", fieldName)
						} else {
							keyFieldDesc := mapEntry.Fields[0]
							valueFieldDesc := mapEntry.Fields[1]

							keyGoType := getGoScalarType(keyFieldDesc.Desc.Kind())

							var valueGoType string
							if valueFieldDesc.Message != nil {
								valueGoType = "*" + g.QualifiedGoIdent(valueFieldDesc.Message.GoIdent)
							} else {
								valueGoType = getGoScalarType(valueFieldDesc.Desc.Kind())
							}
							goType = "map[" + keyGoType + "]" + valueGoType
						}

					} else if field.Message != nil {
						goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
					} else {
						scalarType := getGoScalarType(field.Desc.Kind())

						makePointer := field.Desc.HasOptionalKeyword() || // Proto3 'optional' keyword
							(field.Desc.ContainingOneof() != nil && !field.Desc.ContainingOneof().IsSynthetic()) // Part of a 'real' oneof

						if makePointer {
							goType = "*" + scalarType
						} else {
							goType = scalarType
						}
					}

					// --- Getter Generation ---
					g.P("func (m *", concurrentMsgName, ") ", getterName, "() ", goType, " {")
					g.P("  m.mu.RLock()")
					g.P("  defer m.mu.RUnlock()")

					if field.Message != nil {
						if field.Desc.IsList() {
							g.P("  if m.data.", fieldName, " == nil { return nil }")
							g.P("  clonedSlice := make(", goType, ", len(m.data.", fieldName, "))")
							g.P("  for i, item := range m.data.", fieldName, " {")
							g.P("    if item != nil {")
							g.P("      clonedSlice[i] = proto.Clone(item).(*", g.QualifiedGoIdent(field.Message.GoIdent), ")")
							g.P("    }")
							g.P("  }")
							g.P("  return clonedSlice")
						} else if field.Desc.IsMap() {
							mapEntry := field.Message
							valueFieldDesc := mapEntry.Fields[1]

							g.P("  if m.data.", fieldName, " == nil { return nil }")
							g.P("  clonedMap := make(", goType, ", len(m.data.", fieldName, "))")
							g.P("  for k, v := range m.data.", fieldName, " {")
							if valueFieldDesc.Message != nil {
								valueMsgGoIdent := g.QualifiedGoIdent(valueFieldDesc.Message.GoIdent)
								g.P("    if v != nil {")
								g.P("      clonedMap[k] = proto.Clone(v).(*", valueMsgGoIdent, ")")
								g.P("    } else {")
								g.P("      clonedMap[k] = nil // Preserve nil if original value was nil")
								g.P("    }")
							} else {
								g.P("    clonedMap[k] = v")
							}
							g.P("  }")
							g.P("  return clonedMap")
						} else {
							g.P("  if m.data.", fieldName, " == nil { return nil }")
							g.P("  return proto.Clone(m.data.", fieldName, ").(*", g.QualifiedGoIdent(field.Message.GoIdent), ")")
						}
					} else {
						g.P("  return m.data.", fieldName)
					}
					g.P("}")
					g.P()

					// --- Setter Generation ---
					if field.Oneof == nil {
						g.P("func (m *", concurrentMsgName, ") ", setterName, "(val ", goType, ") {")
						g.P("  m.mu.Lock()")
						g.P("  defer m.mu.Unlock()")
						g.P("  m.data.", fieldName, " = val")
						g.P("}")
						g.P()
					}
				}

				g.P("func (m *", concurrentMsgName, ") GetProtoClone() *", msgName, " {")
				g.P("  m.mu.RLock()")
				g.P("  defer m.mu.RUnlock()")
				g.P("  return proto.Clone(m.data).(*", msgName, ")")
				g.P("}")
				g.P()

				// Caching
				g.P("type ", concurrentMsgName, "Cache struct {")
				g.P("  *InternalCache[string, *", concurrentMsgName, "]")
				g.P("}")
				g.P()
				g.P("func New", concurrentMsgName, "Cache() *", concurrentMsgName, "Cache {")
				g.P("  return &", concurrentMsgName, "Cache{")
				g.P("    NewInternalCache[string, *", concurrentMsgName, "](),")
				g.P("  }")
				g.P("}")
				g.P()
				g.P("func (c *", concurrentMsgName, "Cache) Store(k string, v *", concurrentMsgName, ") {")
				g.P("  if v == nil {")
				g.P("    c.InternalCache.Delete(k)")
				g.P("    return")
				g.P("  }")
				g.P("  protoDataClone := v.GetProtoClone()")
				g.P("  instanceForCache := New", concurrentMsgName, "(protoDataClone)")
				g.P("  c.InternalCache.Store(k, instanceForCache)")
				g.P("}")
				g.P()
				g.P("func (c *", concurrentMsgName, "Cache) Load(k string) *", concurrentMsgName, " {")
				g.P("  defaultValueIfNew := New", concurrentMsgName, "(nil)")
				g.P("  cachedWrapper, loaded := c.InternalCache.LoadOrStore(k, defaultValueIfNew)")
				g.P("  if loaded {")
				g.P("    if cachedWrapper == nil {")
				g.P("      return New", concurrentMsgName, "(nil)")
				g.P("    }")
				g.P("    return New", concurrentMsgName, "(cachedWrapper.GetProtoClone())")
				g.P("  }")
				g.P("  return cachedWrapper")
				g.P("}")
				g.P()
				g.P("func (c *", concurrentMsgName, "Cache) Get(k string) (*", concurrentMsgName, ", bool) {")
				g.P("  cachedWrapper, ok := c.InternalCache.Load(k)")
				g.P("  if !ok || cachedWrapper == nil {")
				g.P("    return nil, false")
				g.P("  }")
				g.P("  return New", concurrentMsgName, "(cachedWrapper.GetProtoClone()), true")
				g.P("}")
				g.P()
				g.P("func (c *", concurrentMsgName, "Cache) Delete(k string) {")
				g.P("  c.InternalCache.Delete(k)")
				g.P("}")
				g.P()
				g.P("func (c *", concurrentMsgName, "Cache) DeleteAll() {")
				g.P("  c.InternalCache.Range(func(key string, value *", concurrentMsgName, ") bool {")
				g.P("    c.InternalCache.Delete(key)")
				g.P("    return true")
				g.P("  })")
				g.P("}")
				g.P()
				g.P("func (c *", concurrentMsgName, "Cache) Len() int {")
				g.P("  count := 0")
				g.P("  c.InternalCache.Range(func(key string, value *", concurrentMsgName, ") bool {")
				g.P("    count++")
				g.P("    return true")
				g.P("  })")
				g.P("  return count")
				g.P("}")
				g.P()

				// LoadOrSet examples
				// userID := "user-123"
				// userCache.LoadOrSet(userID, func() (*UserProto, error) {
				// 	// This function is only called if userID is not in the cache
				// 	// or if the loader is called concurrently by multiple goroutines for the same new key.
				// 	log.Printf("Cache miss for user %s, fetching from DB", userID)
				// 	return db.GetUser(userID) // db.GetUser returns (*UserProto, error)
				// })
				//
				// endpointKey := "externalAPI:/products/456"
				// apiCache.LoadOrSet(endpointKey, func() (*ProductProto, error) {
				// 	log.Printf("Cache miss for %s, calling external API", endpointKey)
				// 	return externalAPI.GetProduct("456")
				// })
				g.P("func (c *", concurrentMsgName, "Cache) LoadOrSet(k string, loaderFunc func() (*", msgName, ", error)) (msg *", concurrentMsgName, ", err error) {")
				// 1. Quick check: Is it already in the cache?
				g.P("  cachedWrapper, ok := c.InternalCache.Load(k)")
				g.P("  if ok && cachedWrapper != nil {")
				// Yes. Return a clone for safety.
				g.P("    return New", concurrentMsgName, "(cachedWrapper.GetProtoClone()), nil")
				g.P("  }")
				g.P()
				// 2. Not in cache (or was nil). Call the loader function to get the data.
				// This might be slow (DB call, network request, complex computation).
				g.P("  defer func() {") // catch loader panics
				g.P("    if r := recover(); r != nil {")
				g.P("      if e, ok := r.(error); ok {")
				g.P("        err = e")
				g.P("      }")
				g.P("    }")
				g.P("  }()")
				g.P("  loadedProtoData, err := loaderFunc()")
				g.P("  if err != nil {")
				g.P("    return nil, err") // Loader failed, propagate error.
				g.P("  }")
				g.P()
				// 3. Prepare the wrapper for storing in the cache.
				// The actual *ConcurrentElement instance stored in the cache will be this new one.
				g.P("  var wrapperToStoreIfNew *", concurrentMsgName)
				g.P("  if loadedProtoData == nil {")
				g.P("    wrapperToStoreIfNew = New", concurrentMsgName, "(nil)")
				g.P("  } else {")
				// Create a new wrapper with the loaded (potentially cloned) proto data.
				g.P("    wrapperToStoreIfNew = New", concurrentMsgName, "(loadedProtoData)")
				g.P("  }")
				g.P()
				// 4. Attempt to store it. LoadOrStore is atomic.
				// - If 'k' was still not present, 'wrapperToStoreIfNew' is stored, and 'actualWrapperInCache' will be 'wrapperToStoreIfNew'.
				// - If another goroutine just stored a value for 'k' between step 1 and here,
				//   'wrapperToStoreIfNew' is NOT stored, and 'actualWrapperInCache' will be the one stored by the other goroutine.
				g.P("  actualWrapperInCache, _ := c.InternalCache.LoadOrStore(k, wrapperToStoreIfNew)")
				g.P()
				// 5. Return a clone of whatever ended up in the cache (either ours or the one from a concurrent write).
				g.P("  if actualWrapperInCache == nil {")
				g.P("    return New", concurrentMsgName, "(nil), nil")
				g.P("  }")
				g.P("  return New", concurrentMsgName, "(actualWrapperInCache.GetProtoClone()), nil")
				g.P("}")
				g.P()

				// Update example
				// orderID := "order-123"
				// orderCache.Update(orderID, func(currentOrder *OrderProto) (*OrderProto, error) {
				// 	if currentOrder == nil {
				// 		return nil, fmt.Errorf("order %s not found", orderID)
				// 	}
				// 	if currentOrder.Status == "PROCESSING" {
				// 		updatedOrder := proto.Clone(currentOrder).(*OrderProto)
				// 		updatedOrder.Status = "SHIPPED"
				// 		return updatedOrder, nil
				// 	}
				// 	// No change if status is not PROCESSING
				// 	return currentOrder, nil // Return original if no change needed
				// })
				g.P("func (c *", concurrentMsgName, "Cache) Update(k string, updateFunc func(currentProto *", msgName, ") (*", msgName, ", error)) (*", concurrentMsgName, ", error) {")
				g.P("  for {")
				// CAS loop: Read-Modify-CompareAndSwap
				// 1. Load the current item (if any) from the cache.
				// We need the raw CacheItem for CompareAndSwap later.
				g.P("    var currentProtoValueForUpdate *", msgName)
				g.P("    var oldCacheItem *CacheItem[*", concurrentMsgName, "]")
				g.P("    itemExistsInCache := false")
				g.P()
				g.P("    loadedItem, found := c.InternalCache.LoadItem(k)")
				g.P("    if found {")
				g.P("      itemExistsInCache = true")
				g.P("      oldCacheItem = loadedItem")
				g.P("      if loadedItem != nil && loadedItem.Value != nil {")
				// Give the updateFunc a CLONE of the current proto data, so it can't
				// accidentally modify the live cached object before CAS.
				g.P("        currentProtoValueForUpdate = loadedItem.Value.GetProtoClone()")
				g.P("      }")
				g.P("    }")
				g.P()
				// 2. Call the user-provided updateFunc.
				// It receives the current data (or nil) and returns the new desired data.
				g.P("    newProtoData, err := updateFunc(currentProtoValueForUpdate)")
				g.P("    if err != nil {")
				g.P("      return nil, err") // Update logic failed
				g.P("    }")
				g.P()
				// 3. Prepare the new wrapper to store.
				g.P("    var newWrapperValueToStore *", concurrentMsgName)
				g.P("    if newProtoData == nil {")
				g.P("      newWrapperValueToStore = New", concurrentMsgName, "(nil)")
				g.P("    } else {")
				g.P("      newWrapperValueToStore = New", concurrentMsgName, "(newProtoData)")
				g.P("    }")
				g.P()
				// 4. Attempt to atomically update.
				g.P("    if !itemExistsInCache {")
				// Item wasn't there to begin with. Try to LoadOrStore.
				// If another goroutine stored something in the meantime, LoadOrStore handles it.
				// We might 'win' the store or 'lose' to a concurrent store.
				g.P("      storedWrapper, loaded := c.InternalCache.LoadOrStore(k, newWrapperValueToStore)")
				g.P("      if !loaded {") // We successfully stored our new value (or it was nil and stayed nil)
				g.P("        if storedWrapper == nil { return New", concurrentMsgName, "(nil), nil }")
				g.P("        return New", concurrentMsgName, "(storedWrapper.GetProtoClone()), nil")
				g.P("      }")
				// Item was loaded by another goroutine, our updateFunc was based on stale/no data. Retry.
				g.P("      continue")
				g.P("    }")
				g.P()
				// Item existed. Attempt CompareAndSwap.
				// This succeeds only if 'oldCacheItem' is still the current item for 'k'.
				g.P("    if c.InternalCache.CompareAndSwap(k, oldCacheItem, newWrapperValueToStore) {")
				// Update is committed.
				g.P("      if newWrapperValueToStore == nil { return New", concurrentMsgName, "(nil), nil }")
				g.P("      return New", concurrentMsgName, "(newWrapperValueToStore.GetProtoClone()), nil")
				g.P("    }")
				// CAS failed: The item was changed by another goroutine between our LoadItem and CompareAndSwap.
				// Loop again to get the fresh value and re-apply the update logic.
				g.P("  }")
				g.P("}")
				g.P()
			}
		}
		return nil
	})
}
