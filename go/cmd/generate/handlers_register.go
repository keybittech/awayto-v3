package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type HandlerInfo struct {
	Name string
}

type TemplateData struct {
	Handlers []HandlerInfo
	Package  string
}

const registerTemplate = `// Code generated by make go_build_register; DO NOT EDIT.
package {{ .Package }}

func (h *Handlers) registerHandlers() {
	if h.Functions == nil {
		h.Functions = make(map[string]HandlerWrapper)
	}
	
	{{- range .Handlers }}
	h.Functions["{{ .Name }}"] = Register(h.{{ .Name }})
	{{- end }}
}
`

func main() {
	// Get current working directory
	pwd, err := os.Getwd()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting working directory: %v\n", err)
		os.Exit(1)
	}

	// Path to handlers directory
	handlersDir := filepath.Join(pwd, "pkg", "handlers")

	// Extract package name and find handler functions
	fset := token.NewFileSet()
	packages, err := parser.ParseDir(fset, handlersDir, nil, 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing handlers directory: %v\n", err)
		os.Exit(1)
	}

	var data TemplateData
	data.Package = "handlers" // Default package name

	for pkgName, pkg := range packages {
		// Use the actual package name from the files
		data.Package = pkgName

		for _, file := range pkg.Files {
			// Skip the register.go file itself
			if strings.HasSuffix(file.Name.String(), "register.go") {
				continue
			}

			// Find handler methods
			for _, decl := range file.Decls {
				funcDecl, ok := decl.(*ast.FuncDecl)
				if !ok || funcDecl.Recv == nil {
					continue // Not a method or no receiver
				}

				// Check if it's a method on *Handlers
				if len(funcDecl.Recv.List) == 0 {
					continue
				}

				starExpr, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr)
				if !ok {
					continue // Not a pointer receiver
				}

				ident, ok := starExpr.X.(*ast.Ident)
				if !ok || ident.Name != "Handlers" {
					continue // Not a *Handlers receiver
				}

				// Check for the signature pattern of handler functions with 5 parameters
				if funcDecl.Type.Params != nil && len(funcDecl.Type.Params.List) == 5 {
					// Check if the third parameter is a proto.Message
					thirdParam := funcDecl.Type.Params.List[2]

					// We need to inspect the type of the third parameter
					isProtoMessage := false

					// Check for pointer to a type that might implement proto.Message
					if starExpr, ok := thirdParam.Type.(*ast.StarExpr); ok {
						// For imported types, they might be in the form of *types.SomeProtoType
						if sel, ok := starExpr.X.(*ast.SelectorExpr); ok {
							// Check if this is from a package that might contain proto messages
							// (This is an approximate check, as we can't verify implementation at parse time)
							if ident, ok := sel.X.(*ast.Ident); ok {
								// Common import names for proto packages
								if ident.Name == "types" || ident.Name == "proto" ||
									strings.HasSuffix(ident.Name, "pb") {
									isProtoMessage = true
								}
							}
						}
					} else if _, ok := thirdParam.Type.(*ast.InterfaceType); ok {
						// Check if this is directly a proto.Message interface
						// This would be represented by an interface type with proto.Message methods
						isProtoMessage = true
					}

					if isProtoMessage {
						data.Handlers = append(data.Handlers, HandlerInfo{
							Name: funcDecl.Name.Name,
						})
					}
				}
			}
		}
	}

	// Create or truncate the register.go file
	registerGoPath := filepath.Join(handlersDir, "register.go")
	file, err := os.Create(registerGoPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating register.go: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	// Parse template
	tmpl, err := template.New("register").Parse(registerTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	// Execute template
	err = tmpl.Execute(file, data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s with %d handlers\n", registerGoPath, len(data.Handlers))
}
