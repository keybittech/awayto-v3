package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/keybittech/awayto-v3/go/pkg/util"
)

type HandlerInfo struct {
	Name string
}

type TemplateData struct {
	Handlers []HandlerInfo
}

const registerTemplate = `// Code generated by make handlers_register; DO NOT EDIT.
package handlers

import (
	"errors"

	"google.golang.org/protobuf/proto"
)


func registerProtoHandler[ReqMsg, ResMsg proto.Message](handler TypedProtoHandler[ReqMsg, ResMsg]) ProtoHandler {
	return func(info ReqInfo, message proto.Message) (proto.Message, error) {
		msg, ok := message.(ReqMsg)
		if !ok {
			return nil, errors.New("invalid request type")
		}

		return handler(info, msg)
	}
}

func registerHandlers(h *Handlers) {
	{{- range .Handlers }}
	h.Functions["{{ .Name }}"] = registerProtoHandler(h.{{ .Name }})
	{{- end }}
}
`

// Loop through all the handler files, ensure the func signature
// collect all elements into a callable function which will assign
// the runtime funcs to the API
func main() {
	util.ParseEnv()

	fset := token.NewFileSet()

	handlersPath := strings.TrimSpace(filepath.Join(util.E_PROJECT_DIR, "go", "pkg", "handlers"))

	packages, err := parser.ParseDir(fset, handlersPath, nil, 0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing handlers directory: %v\n", err)
		os.Exit(1)
	}

	var data TemplateData

	for _, pkg := range packages {

		for _, file := range pkg.Files {
			if strings.HasSuffix(file.Name.String(), "register.go") {
				continue
			}

			for _, decl := range file.Decls {
				funcDecl, ok := decl.(*ast.FuncDecl)
				if !ok || funcDecl.Recv == nil {
					continue
				}

				if len(funcDecl.Recv.List) == 0 {
					continue
				}

				starExpr, ok := funcDecl.Recv.List[0].Type.(*ast.StarExpr)
				if !ok {
					continue
				}

				ident, ok := starExpr.X.(*ast.Ident)
				if !ok || ident.Name != "Handlers" {
					continue
				}

				// Validate parameters: should have exactly 2 parameters
				if funcDecl.Type.Params == nil || len(funcDecl.Type.Params.List) != 2 {
					continue
				}

				// First return parameter should be from types package
				infoParam := funcDecl.Type.Params.List[0]
				isInfoParam := false
				if infoStruct, ok := infoParam.Type.(*ast.Ident); ok {
					if infoStruct.Name == "ReqInfo" {
						isInfoParam = true
					}
				}

				if !isInfoParam {
					continue
				}

				protoParam := funcDecl.Type.Params.List[1]
				isProtoMessage := false
				if starExpr, ok := protoParam.Type.(*ast.StarExpr); ok {
					if sel, ok := starExpr.X.(*ast.SelectorExpr); ok {
						if ident, ok := sel.X.(*ast.Ident); ok && ident.Name == "types" {
							isProtoMessage = true
						}
					}
				}

				if !isProtoMessage {
					continue
				}

				// Validate return parameters: should have exactly 2 return values
				if funcDecl.Type.Results == nil || len(funcDecl.Type.Results.List) != 2 {
					continue
				}

				// First return parameter should be from types package
				firstReturn := funcDecl.Type.Results.List[0]
				isFirstReturnFromTypes := false
				if starExpr, ok := firstReturn.Type.(*ast.StarExpr); ok {
					if sel, ok := starExpr.X.(*ast.SelectorExpr); ok {
						if ident, ok := sel.X.(*ast.Ident); ok && ident.Name == "types" {
							isFirstReturnFromTypes = true
						}
					}
				}

				if !isFirstReturnFromTypes {
					continue
				}

				// Second return parameter should be error
				secondReturn := funcDecl.Type.Results.List[1]
				isSecondReturnError := false
				if ident, ok := secondReturn.Type.(*ast.Ident); ok && ident.Name == "error" {
					isSecondReturnError = true
				}

				if !isSecondReturnError {
					continue
				}

				// If we get here, the function meets all criteria
				data.Handlers = append(data.Handlers, HandlerInfo{
					Name: funcDecl.Name.Name,
				})
			}
		}
	}

	handlersRegisterFile := filepath.Join("go", "pkg", "handlers", "register.go")

	file, err := util.GetCleanPath(handlersRegisterFile, os.O_CREATE)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error cleaning register.go: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	tmpl, err := template.New("register").Parse(registerTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	err = tmpl.Execute(file, data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s with %d handlers\n", handlersRegisterFile, len(data.Handlers))
}
